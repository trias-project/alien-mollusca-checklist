---
title: "Darwin Core mapping"
subtitle: "For: alien-mollusca-checklist"
author:
- Lien Reyserhove
date: "`r Sys.Date()`"
output:
  html_document:
    df_print: paged
    number_sections: yes
    toc: yes
    toc_depth: 3
    toc_float: yes
#  pdf_document:
#    df_print: kable
#    number_sections: yes
#    toc: yes
#    toc_depth: 3
---

# Setup 

```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```

Load libraries:

```{r}
library(tidyverse)      # To do data science
library(tidylog)        # To provide feedback on dplyr functions
library(magrittr)       # To use %<>% pipes
library(here)           # To find files
library(janitor)        # To clean input data
library(readxl)         # To read Excel files
library(digest)         # To generate hashes
library(rgbif)          # To use GBIF services
library(googlesheets)   # To import and read Google spreadsheets 
```

# Read source data

Set column types:

```{r}
col_types = cols(
   .default = col_character(),
    other_col = col_double())
```

The original spreadsheet can be found [here](https://docs.google.com/spreadsheets/d/1hSXd6SZQUvI8uGbE_5-vmN8ZZz739D46HRt2aTFcb-s/edit#gid=0). We need to retrieve this spreadsheet and select the specific worksheet first:

Retrieve the spreadsheet:

```{r connect_google_spreadsheets}
retrieve_spreadsheet <- gs_title("alien mollusca checklist")
```

Select the data in the worksheet `checklist`:

```{r read_source_data}
input_taxon <- retrieve_spreadsheet %>% gs_read("taxon", col_types = col_types)
input_vernacular_names <- retrieve_spreadsheet %>% gs_read("vernacular_names", col_types = col_types)
input_synonyms <- retrieve_spreadsheet %>% gs_read("synonyms", col_types = col_types)
```

```{r}
input_distribution <- retrieve_spreadsheet %>% gs_read("distribution", col_types = col_types)
input_description <- retrieve_spreadsheet %>% gs_read("description", col_types = col_types)
input_references <- retrieve_spreadsheet %>% gs_read("references", col_types = col_types)
```


We want to add a copy of the source data to the repository:

```{r}
write_csv(input_taxon, here("data", "raw", "input_taxon.csv"), na = "")
write_csv(input_vernacular_names, here("data", "raw", "input_vernacular_names.csv"), na = "")
write_csv(input_synonyms, here("data", "raw", "input_synonyms.csv"), na = "")
write_csv(input_distribution, here("data", "raw", "input_distribution.csv"), na = "")
write_csv(input_description, here("data", "raw", "input_description.csv"), na = "")
write_csv(input_references, here("data", "raw", "input_references.csv"), na = "")
```

# Pre-processing

## Scientific names

Use the [GBIF nameparser](https://www.gbif.org/tools/name-parser) to retrieve nomenclatural information for the scientific names in the checklist:

```{r}
parsed_names <- input_taxon %>%
  distinct(scientific_name) %>%
  pull() %>% # Create vector from dataframe
  parsenames() # An rgbif function
```

All scientific names are of `type = SCIENTIFIC` and need no further processing.

## Taxon ranks

The nameparser function also provides information about the rank of the taxon (in `rankmarker`). Here we join this information with our checklist. Cleaning these ranks will done in the Taxon Core mapping:

```{r}
input_taxon %<>% left_join(
  select(parsed_names, scientificname, rankmarker),
  by = c("scientific_name" = "scientificname"))
```

## Taxon IDs

To link taxa with information in the extension(s), each taxon needs a unique and relatively stable `taxonID`.
Here we create one in the form of `dataset_shortname:taxon:hash`, where `hash` is unique code based on scientific name. We save this as a separate dataframe as we want to append this information to each generated file here:

```{r}
vdigest <- Vectorize(digest) # Vectorize digest function to work with vectors
taxon_id <- input_taxon %>% 
  mutate(taxon_id = paste("alien-mollusca-checklist", 
                          "taxon",
                          vdigest(scientific_name, algo = "md5"), 
                          sep = ":")) %>% 
  select(scientific_name, taxon_id)
```

# Taxon core

## Pre-processing

Create a dataframe with unique taxa:

```{r}
input_taxon %<>% distinct(scientific_name, .keep_all = TRUE)
```

## Term mapping

Map the data to [Darwin Core Taxon](http://rs.gbif.org/core/dwc_taxon_2015-04-24.xml).

Start with record-level terms which contain metadata about the dataset (which is generally the same for all records).

### language

```{r}
input_taxon %<>% mutate(dwc_language = "en")
```

### license

```{r}
input_taxon %<>% mutate(dwc_license = "http://creativecommons.org/publicdomain/zero/1.0/")
```

### rightsHolder

```{r}
input_taxon %<>% mutate(dwc_rightsHolder = "Royal Belgian Institute of Natural Sciences")
```

### bibliographicCitation

### datasetID

```{r}
input_taxon %<>% mutate(dwc_datasetID = "")
```

### institutionCode

```{r}
input_taxon %<>% mutate(dwc_institutionCode = "RBINS")
```

### datasetName

```{r}
input_taxon %<>% mutate(dwc_datasetName = "Registry of introduced terrestrial molluscs in Belgium")
```

The following terms contain information about the taxon:

### taxonID

Merge with `taxon_id`:

```{r}
input_taxon %<>% left_join(taxon_id, by = "scientific_name")
```

Rename to `dwc_taxonID`:

```{r}
input_taxon %<>% rename("dwc_taxonID" = "taxon_id") 
```
 

### scientificName

```{r}
input_taxon %<>% mutate(dwc_scientificName = scientific_name)
```

### kingdom

```{r}
input_taxon %<>% mutate(dwc_kingdom = "Animalia")
```

### phylum

```{r}
input_taxon %<>% mutate(dwc_phylum = "Mollusca") 
```

### class

```{r}
input_taxon %<>% mutate(dwc_class = class)
```

### order

```{r}
input_taxon %<>% mutate(dwc_order = order) 
```

### family

```{r}
input_taxon %<>% mutate(dwc_family = family) 
```

### genus

```{r}
input_taxon %<>% mutate(dwc_genus = genus)
```

### taxonRank

Inspect values:

```{r}
input_taxon %>%
  group_by(rankmarker) %>%
  count()
```

Map values by recoding to the [GBIF rank vocabulary](http://rs.gbif.org/vocabulary/gbif/rank_2015-04-24.xml):

```{r}
input_taxon %<>% mutate(dwc_taxonRank = recode(rankmarker,
  "sp."       = "species",
  .default    = "",
  .missing    = ""
))
```

Inspect mapped values: 

```{r}
input_taxon %>%
  group_by(rankmarker, dwc_taxonRank) %>%
  count()
```

### nomenclaturalCode

```{r}
input_taxon %<>% mutate(dwc_nomenclaturalCode = "ICZN")
```

### taxonRemarks

## Post-processing

Only keep the Darwin Core columns:

```{r}
taxon %<>% select(starts_with("dwc_"))
```

Drop the `dwc_` prefix:

```{r}
colnames(taxon) <- str_remove(colnames(taxon), "dwc_")
```

Preview data:

```{r}
taxon %>% head()
```

Save to CSV:

```{r}
write_csv(taxon, here("data", "processed", "taxon.csv"), na = "")
```

# Vernacular names extension

## Term mapping

Map the data to [Vernacular Names](http://rs.gbif.org/extension/gbif/1.0/vernacularname.xml).

### taxonID

Merge with `taxon_id`:

```{r}
input_vernacular_names %<>% left_join(taxon_id, by = "scientific_name")
```

Rename to `dwc_taxonID`:

```{r}
input_vernacular_names %<>% rename("dwc_taxonID" = "taxon_id") 
```
 
### vernacularName

```{r}
input_vernacular_names %<>% mutate(dwc_vernacularName = vernacular_name)
```

### language

```{r}
input_vernacular_names %>%
  group_by(language) %>% 
  summarize(records = n())
```


This column currently contains the original column name, which we will recode to the ISO 639-1 language code:

```{r}
input_vernacular_names %<>% mutate(dwc_language = recode(language,
  "dutch" = "nl",
  "english" = "en",
  "french" = "fr",
  "german" = "de"
))
```

## Post-processing

Remove the original columns: 

```{r}
input_vernacular_names %<>% select(
  -starts_with("dwc"))
```

Drop the `dwc_` prefix:

```{r}
colnames(input_vernacular_names) <- str_remove(colnames(input_vernacular_names), "dwc_")
```

Preview data:

```{r}
input_vernacular_names %>% head()
```

Save to CSV:

```{r}
write_csv(input_vernacular_names, here("data", "processed", "vernacularnames.csv"), na = "")
```

# Distribution extension

## Term mapping

Map the data to [Species Distribution](http://rs.gbif.org/extension/gbif/1.0/distribution.xml).

### taxonID

```{r}
input_distribution %<>% mutate(dwc_taxonID = taxon_id)
```

### locationID

```{r}
input_distribution %<>% mutate(dwc_locationID = "ISO_3166-2:BE") 
```

### locality

```{r}
input_distribution %<>% mutate(dwc_locality = "Belgium") 
```

### countryCode

```{r}
input_distribution %<>% mutate(dwc_countryCode = "BE") 
```

### occurrenceStatus 

```{r}
input_distribution %<>% mutate(dwc_occurrenceStatus = occurrence_status) 
```

### establishmentMeans

```{r}
input_distribution %<>% mutate(dwc_establishmentMeans = "introduced") 
```

### eventDate

The dataset contains two fields with date information: `first_observation`, which is always populated, and `last_observation`, which is often empty. From these columns, we create `eventDate` (ISO 8601 format: `yyyy` or `yyyy`/`yyyy`).

```{r}
input_distribution %<>% mutate(eventDate = case_when(
  is.na(last_observation) ~ first_observation,
  TRUE ~ paste(first_observation, last_observation, sep = "/")))
```

### source

Information for source can be found in `source_distribution`.

```{r}
input_distribution %<>% mutate(dwc_source = source_distribution) 
```

## Post-processing

Only keep the Darwin Core columns:

```{r}
input_distribution %<>% select(starts_with("dwc_"))
```

Drop the `dwc_` prefix:

```{r}
colnames(input_distribution) <- str_remove(colnames(input_distribution), "dwc_")
```

Preview data:

```{r}
input_distribution %>% head()
```

Save to CSV:

```{r}
write_csv(input_distribution, here("data", "processed", "distribution.csv"), na = "")
```

## Description extension

In the description extension we want to include several important characteristics (hereafter refered to as descriptors) about the species:

- Native range
- Pathway of introduction
- Degree of establishment

A single taxon can have multiple descriptions of the same type (e.g. multiple native ranges), expressed as multiple rows in the description extension.

For each descriptor, we create a separate dataframe to process the specific information. We always specify _which descriptor_ we map (`type` column) and its _specific content_ (`description` column). After the mapping of these Darwin Core terms `type` and `value`, we merge the dataframes to generate one single description extension. We then continue the mapping process by adding the other Darwin Core terms (which content is independent of the type of descriptor, such as `language`).

### Native range

Create separate dataframe:

```{r start_native_range}
native_range <- input_description
```

Inspect data:

```{r}
native_range %>% 
  group_by(native_range) %>% 
  summarize(records = n())
```

Separate by `,`:

```{r}
native_range %<>% separate(native_range, 
                          into = paste("native_range",c(1:9),sep="_"),
                          sep = ",")
```

Gather data:

```{r}
native_range %<>% gather(key = "native_range",
                         value = "value",
                         paste("native_range",c(1:9),sep="_"),
                         na.rm = TRUE)
```

Inspect data:

```{r}
native_range %>% 
  group_by(value) %>% 
  summarize(records = n())
```

Trim whitespace:

```{r}
native_range %<>% mutate(value = str_trim(value))
```

Create `description` from `value`:

```{r}
native_range %<>% mutate(description = value)
```

Create `type`:

```{r}
native_range %<>% mutate(type = "native range") 
```

Remove `native_range`:

```{r}
native_range %<>% select(-native_range) 
```

## Pathways

Create separate dataframe:

```{r start_pathways}
pathways <- input_description
```

Inspect data:

```{r}
pathways %>% 
  group_by(introduction_pathway) %>% 
  summarize(records = n())
```

To be continued after cleaning by Thierry

## Degree of establishment

Create separate dataframe:

```{r start_pathways}
pathways <- input_description
```

Inspect data:

```{r}
pathways %>% 
  group_by(degree_of_establishment) %>% 
  summarize(records = n()) %>% 
  kable()
```


