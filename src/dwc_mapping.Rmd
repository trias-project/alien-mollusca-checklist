---
title: "Darwin Core mapping"
subtitle: "For: alien-mollusca-checklist"
author:
- Lien Reyserhove
- Sanne Govaert
date: "`r Sys.Date()`"
output:
  html_document:
    df_print: paged
    number_sections: yes
    toc: yes
    toc_depth: 3
    toc_float: yes
---

# Setup 

```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```

Load libraries:

```{r}
library(tidyverse)      # To do data science
library(magrittr)       # To use %<>% pipes
library(here)           # To find files
library(janitor)        # To clean input data
```

# Read source data

The data is maintained in [this Google Spreadsheet](https://docs.google.com/spreadsheets/d/1LeXXbry2ArK2rngsmFjz_xErwE1KwQ8ujtvHNmTVA6E/edit?gid=1518765324#gid=1518765324).

Read the relevant worksheet (published as csv):

```{r read_source_data}
raw_data <- read_csv("https://docs.google.com/spreadsheets/d/e/2PACX-1vTl8IEk2fProQorMu5xKQPdMXl3OQp-c0f6eBXitv0BiVFZ3JSJCde0PtbFXuETgguf6vK8b43FDX1C/pub?gid=1518765324&single=true&output=csv", show_col_types = FALSE)
```

```{r}
input_synonyms <- read_csv("https://docs.google.com/spreadsheets/d/e/2PACX-1vTmhKKSsWpFKdJW2f2RsVy9VCnkdkBJ76Fo8romrvqcrP6nd4TH4eyNsviJyUdL2zRFvu8LM6FQEVhG/pub?gid=1318103769&single=true&output=csv", show_col_types = FALSE)
```

Copy the source data to the repository to keep track of changes:

```{r}
write_csv(raw_data, here("data", "raw", "alien_mollusca_dump.csv"), na = "")
write_csv(input_synonyms, here("data", "raw", "input_synonyms.csv"), na = "")
```

# Preprocessing: tidy data and add taxon ID's

`input_synonyms` and `input_references` contain empty rows, we remove those here:

```{r}
input_synonyms %<>% remove_empty("rows") 
```

To link taxa with information in the extension(s), each taxon needs a unique and relatively stable `taxonID`. We have created one in the form of `dataset_shortname:taxon:hash`, where `hash` is unique code based on scientific name and kingdom. Once this is created, it is added to the source data. 

```{r}
input_data <-
  raw_data %>%
  remove_empty("rows") %>%
  clean_names() %>%
  mutate(
    taxon_id = paste(
      "alien-mollusca-checklist",
      "taxon",
      .data$taxon_id_hash,
      sep = ":"
    )
  )
```

# Taxon core

## Pre-processing

Taxonomic information is provided in two different dataframes: 
- `input_data` including all _accepted_ scientific names
- `input_synonyms` including all scientific names of _synonyms_

For some of the taxa, the original name is provided, i.e. the scientific name as it originally appeared when the name was first established under the rules of the associated nomenclatural code. These original names can be extracted from `input_synyms`: these are the `scientific_name` for which `remarks` = `original name`. 

For each scientific name in this checklist (accepted or synonym), the taxon Core will thus inlcude the following information

- `taxon_id`: taxon_id of the scientific name
- `accepted_name_usage_id`: taxon_id of the _accepted_ scientific name
- `scientific_name`
- `accepted_name_usage`: the _accepted_ scientific name
- `taxonomic_status`: `accepted`, `homotypicSynonym` (for original names) and `heterotypicSynoym` (for all other synonyms)
- higher classification information: `class`, `order`, `family` and `genus` 

We map these terms in three steps:

1. Generate `accepted_taxa` which contains all terms for the _accepted_ scientific names (in `input_data`).
  - `taxon_id`, `scientific_name` and the higher classification is already provided
  - Map `taxonomic_status` (= `accepted`), `accepted_name_usage` (= `scientific_name`) and `accepted_name_usage_id` (= `taxon_id`)
  
2. Generate `synonyms` which contains all terms for the _synonyms_ (in `input_synonyms`). 
  - `scientific_name` is already provided
  - Add higher classification `class`, `order`, `family` and `genus` by joining with `input_data`
  - Generate `taxon_id`
  - Map `taxonomic_status` (= `homotypicSynonym` or `heterotypicSynoym`), `accepted_name_usage` (= `synonym_of`) and `accepted_name_usage_id` (= `taxon_id` from `taxon`)
  
3. Join  `synonyms` with `accepted_taxa` using the dplyr funtion `bind_rows()`

### Generate accepted_taxa

Generate `accepted_taxa` by extracting all taxonomic information from `input_data`:

```{r}
accepted_taxa <- input_data %>% select(taxon_id, scientific_name, class, order, family, genus, taxon_remarks)
```

Map `taxonomic_status` which is `accepted`:

```{r}
accepted_taxa %<>% mutate(taxonomic_status = "accepted")
```

Map `accepted_name_usage` and `accepted_name_usage_id`:

```{r}
accepted_taxa <-
  accepted_taxa %>% 
    mutate(accepted_name_usage = scientific_name) %>% 
    mutate(accepted_name_usage_id = taxon_id)
```

Order terms to enable future join with `synonyms`:

```{r}
accepted_taxa %<>% select(taxon_id, accepted_name_usage_id, scientific_name, accepted_name_usage, class, order, family, genus, taxonomic_status, taxon_remarks) 
```

### Generate synonyms

Join `synonyms` with `accepted_taxa` to extract higher classification:

```{r}
synonyms <- 
  input_synonyms %>% 
    left_join(
      select(accepted_taxa, scientific_name, taxon_id, class, order, family, genus),
      by = c("synonym_of" = "scientific_name"))
```

Rename  `taxon_id` from `accepted_taxa` to avoid confusion with the future mapping of `taxon_id` from `synonyms`:

```{r}
synonyms %<>% rename("taxon_id_accepted" = "taxon_id")
```

Map `taxon_id` for synonyms:

```{r}
vdigest <- Vectorize(digest) # Vectorize digest function to work with vectors
synonyms %<>% 
  mutate(taxon_id = paste("alien-mollusca-checklist", 
                          "taxon",
                          vdigest(scientific_name, algo = "md5"), 
                          sep = ":"))
```

One scientific name is duplicated in `synonyms`:

```{r}
synonyms %>% 
  slice(which(duplicated(synonyms$scientific_name))) %>% 
  select(scientific_name)
```

This is because `Helix balteata Pollonera, 1892` is both a synonym of `Cernuella virgata (Da Costa, 1778)` and `Cernuella cisalpina (Rossmässler, 1837)`. We need to manually adjust the  `taxonID` for these records:

```{r}
synonyms %<>% mutate(taxon_id = case_when(
  scientific_name == "Helix balteata Pollonera, 1892" & synonym_of == "Cernuella virgata (Da Costa, 1778)" ~ paste(taxon_id, "1", sep = ":"),
  scientific_name == "Helix balteata Pollonera, 1892" & synonym_of == "Cernuella cisalpina (Rossmässler, 1837)" ~ paste(taxon_id, "2", sep = ":"),
  TRUE ~ taxon_id))
```

Check whether taxonID's are still duplicated:

```{r}
synonyms %>% 
  slice(which(duplicated(synonyms$taxon_id))) %>% 
  select(scientific_name)
```

Map `taxonomic_status`. 

```{r}
synonyms %<>% mutate(taxonomic_status = case_when(
  scientific_name == "Helix balteata Pollonera, 1892" ~ "proParteSynonym",
  remarks == "original name" ~ "homotypicSynonym",
  TRUE ~ "heterotypicSynonym"))
```

Map `accepted_name_usage` and `accepted_name_usage_id`. This information is provided in `synonym_of` and `taxon_id_accepted` respectively. We thus only need to rename these columns:

```{r}
synonyms <- 
  synonyms %>% 
    rename("accepted_name_usage" = "synonym_of") %>% 
    rename("accepted_name_usage_id" = "taxon_id_accepted")
```

Add `taxonomy` which is empty for most `synonyms`, except for `Ferussacia folliculus Schröter, 1784` and `Ferussacia follicula Schröter, 1784`:

```{r}
synonyms %<>% mutate(taxonomy = case_when(
  scientific_name == "Ferussacia folliculus Schröter, 1784" | 
    scientific_name == "Ferussacia follicula Schröter, 1784" ~ remarks,
  TRUE ~ ""))
```

Rearrange columns to enable future join with `accepted_taxa`:

```{r}
synonyms <- synonyms %>% 
  select(taxon_id, accepted_name_usage_id, scientific_name, accepted_name_usage, class, order, family, genus, taxonomic_status, taxonomy) 
```

Merge both datasets together in `taxon`:

```{r}
taxon <- accepted_taxa %<>% bind_rows(synonyms)
```

## Term mapping

Map the data to [Darwin Core Taxon](http://rs.gbif.org/core/dwc_taxon_2015-04-24.xml).

Start with record-level terms which contain metadata about the dataset (which is generally the same for all records).

### language

```{r}
taxon %<>% mutate(dwc_language = "en")
```

### license

```{r}
taxon %<>% mutate(dwc_license = "http://creativecommons.org/publicdomain/zero/1.0/")
```

### rightsHolder

```{r}
taxon %<>% mutate(dwc_rightsHolder = "Royal Belgian Institute of Natural Sciences")
```

### datasetID

```{r}
taxon %<>% mutate(dwc_datasetID = "https://doi.org/10.15468/t13kwo")
```

### institutionCode

```{r}
taxon %<>% mutate(dwc_institutionCode = "RBINS")
```

### datasetName

```{r}
taxon %<>% mutate(dwc_datasetName = "Registry of introduced terrestrial molluscs in Belgium")
```

The following terms contain information about the taxon:

### taxonID

```{r}
taxon %<>% mutate(dwc_taxonID = taxon_id) 
```

### acceptedNameUsageID

```{r}
taxon %<>% mutate(dwc_acceptedNameUsageID = accepted_name_usage_id) 
```

### scientificName

```{r}
taxon %<>% mutate(dwc_scientificName = scientific_name)
```

### acceptedNameUsage

```{r}
taxon %<>% mutate(dwc_acceptedNameUsage = accepted_name_usage) 
```

### kingdom

```{r}
taxon %<>% mutate(dwc_kingdom = "Animalia")
```

### phylum

```{r}
taxon %<>% mutate(dwc_phylum = "Mollusca") 
```

### class

```{r}
taxon %<>% mutate(dwc_class = class)
```

### order

```{r}
taxon %<>% mutate(dwc_order = order) 
```

### family

```{r}
taxon %<>% mutate(dwc_family = family) 
```

### genus

```{r}
taxon %<>% mutate(dwc_genus = genus)
```

### taxonRank

We can exxtract the taxon rank information from GBIF using the `rgbif` package.

```{r}
taxon_rank <- parsenames(taxon$dwc_scientificName)
```

Remove one 1 for the duplicated scientific name `Helix balteata Pollonera, 1892`:

```{r}
taxon_rank %<>% distinct(scientificname, rankmarker, .keep_all = FALSE)
```

Add information to `taxon`:

```{r}
taxon %<>% 
  left_join(
    select(taxon_rank, scientificname, rankmarker),
    by = c("dwc_scientificName" = "scientificname"))
```

Inspect values for `rankmarker`:

```{r}
taxon %>% 
  group_by(rankmarker) %>% 
  summarize(records = n())
```

Recode values for `rankmarker` in `dwc_taxonRank`

```{r}
taxon %<>% mutate(dwc_taxonRank = recode(rankmarker,
  "f." = "forma",
  "infrasp." = "subspecies",
  "sp." = "species",
  "var." = "variety"))
```

### nomenclaturalCode

```{r}
taxon %<>% mutate(dwc_nomenclaturalCode = "ICZN")
```

### taxonomicStatus

```{r}
taxon %<>% mutate(dwc_taxonomicStatus = taxonomic_status) 
```

### taxonRemarks

```{r}
taxon %<>% mutate(dwc_taxonRemarks = taxon_remarks) 
```

## Post-processing

Only keep the Darwin Core columns:

```{r}
taxon %<>% select(starts_with("dwc_"))
```

Drop the `dwc_` prefix:

```{r}
colnames(taxon) <- str_remove(colnames(taxon), "dwc_")
```

Preview data:

```{r}
taxon %>% head()
```

Save to CSV:

```{r}
write_delim(taxon, here("data", "processed", "taxon.tsv"), delim = "\t", na = "")
```

# Vernacular name extension

Map the data to [Vernacular Nams](http://rs.gbif.org/extension/gbif/1.0/vernacularname.xml).
Vernacular names are available in four languages: Dutch, French, English and German. We will gather these columns to generate a single column containing the vernacular name (`vernacularName`) and an additional column with the language (`language`):

```{r vernacular_name}
vernacular_name <- 
  input_data %>% 
  tidyr::gather(
    key = language,
    value = vernacularName,
    common_name, dutch_name, french_name, german_name,
    na.rm = TRUE,
    convert = TRUE) %>%
  dplyr::mutate(vernacularName = strsplit(vernacularName, "\\|")) %>% 
  unnest(vernacularName) %>% 
  dplyr::mutate(
    taxonID = taxon_id,
    vernacularName = str_trim(vernacularName),
    language = 
      dplyr::recode(
        language,
        "dutch_name" = "nl",
        "french_name" = "fr",
        "common_name" = "en",
        "german_name" = "ge"
        ) 
    ) %>% 
  dplyr::select(taxonID, vernacularName, language) %>% 
  dplyr::arrange(taxonID)
```

## Species profile extension

In this extension we will express broad habitat characteristics of the species (e.g. `isTerrestrial`).

Create a dataframe with unique taxa only (ignoring multiple distribution rows).
Only keep records for which `terrestrial`, `marine` and `freshwater` is not empty.

Map the data to [Species Profile](http://rs.gbif.org/extension/gbif/1.0/speciesprofile.xml).

```{r}
species_profile <-
  input_data %>%
  distinct(taxon_id, .keep_all = TRUE) %>% 
  filter(
    !is.na(terrestrial) |
      !is.na(marine) |
      !is.na(freshwater)
  ) %>% 
  mutate(
    .keep = "none",
    taxonID = taxon_id,
    isMarine = marine,
    isFreshwater = freshwater,
    isTerrestrial = terrestrial
  ) %>% 
  arrange(taxonID)
```

## Distribution extension

Create a dataframe with all data (including multiple distributions). Map the data to [Species Distribution](http://rs.gbif.org/extension/gbif/1.0/distribution.xml).

Information for `eventDate` is contained in `date_first_observation` and `date_last_observation`, which we will express here in an ISO 8601 date format `yyyy/yyyy` (`start_date/end_date`).

Not all cells for `date_first_observation` (DFO) and/or `date_last_observation` (DLO) are populated. So, we used the following rules for those records: 

***case 1.*** If `DFO` is empty and `DLO` is empty, `eventDate` is `NA` 
***case 2.***  If `DFO` is empty and `DLO` is not empty: eventDate = `/DLO`
***case 3.*** If `DFO` is not empty and `DLO` is empty, eventDate is `DFO/`

```{r}
distribution <-
  input_data %>%
  # pathway
  pivot_longer(
    names_to = "key",
    values_to = "pathway",
    starts_with("introduction_pathway"),
    values_drop_na = FALSE) %>%
  filter( # keep NA value for species with no pathway provided
    !is.na(pathway) |
      (is.na(pathway) & key == "introduction_pathway_1")
    ) %>%
  # other terms
  mutate(
    taxonID = taxon_id,
    locationID = case_when(
      location == "Flanders" ~ "ISO_3166-2:BE-VLG",
      location == "Wallonia" ~ "ISO_3166-2:BE-WAL",
      location == "Brussels" ~ "ISO_3166-2:BE-BRU",
      location == "Belgium" ~ "ISO_3166-2:BE"
    ),
    locality = case_when(
      location == "Flanders" ~ "Flemish Region",
      location == "Wallonia" ~ "Walloon Region",
      location == "Brussels" ~ "Brussels-Capital Region",
      location == "Belgium" ~ "Belgium"
    ),
    countryCode = country_code,
    occurrenceStatus = occurrence_status,
    establishmentMeans = establishment_means,
    degreeOfEstablishment = degree_of_establishment,
    eventDate = case_when(
      is.na(date_first_observation) & is.na(date_last_observation) ~ NA,
      is.na(date_first_observation) ~ paste0("/", date_last_observation),
      is.na(date_last_observation) ~ paste0(date_first_observation, "/"),
      !is.na(date_first_observation) & !is.na(date_last_observation) ~
        paste(date_first_observation, date_last_observation, sep = "/")
    ),
    source = source,
    occurrenceRemarks = occurrence_remarks
  ) %>%
  select(
    "taxonID", "locationID", "locality", "countryCode", "occurrenceStatus",
    "establishmentMeans", "degreeOfEstablishment", "pathway", 
    "eventDate", "source", "occurrenceRemarks"
  ) %>%
  arrange(taxonID)
```

## Description extension

In the description extension we want to include the native range of a species

```{r}
description <-
  input_data %>% 
  # unique taxa only (ignoring multiple distribution rows)
  distinct(taxon_id, .keep_all = TRUE) %>% 
  # Separate values on `|` 
  mutate(native_range = strsplit(native_range, "\\|")) %>% 
  unnest(native_range) %>% 
  filter(!is.na(native_range)) %>% 
  mutate(
    .keep = "none",
    taxonID = taxon_id,
    description = str_trim(native_range),
    type = "native range",
    language = "en"
    ) %>% 
  select("taxonID", "description", "type", "language") %>% 
  arrange(taxonID)
```

# Save to CSV:

```{r}
write_delim(taxon, here("data", "processed", "taxon.tsv"), delim = "\t", na = "")

# write_csv(taxon, here("data", "processed", "taxon.csv"), na = "")
write_csv(vernacular_name, here("data", "processed", "vernacularname.csv"), na = "")
write_csv(distribution, here("data", "processed", "distribution.csv"), na = "")
write_csv(species_profile, here("data", "processed", "speciesprofile.csv"), na = "")
write_csv(description, here("data", "processed", "description.csv"), na = "")
```

